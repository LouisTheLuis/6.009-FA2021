(define (range start stop) (if (>= start stop) nil (pair start (range (+ start 1) stop))))
(define (all values) (if (=? (length values) 0) #t (and (head values) (all (tail values)))))
(define (min a b) (if (< a b) a b))
(define (max a b) (if (> a b) a b))
(define (zip a b) (if (or (=? (length a) 0) (=? (length b) 0)) nil (pair (pair (head a) (head b)) (zip (tail a) (tail b)))))
(define (set-nth ll index value) (if (=? index 0) (pair value (tail ll)) (pair (head ll) (set-nth (tail ll) (- index 1) value))))
(define (initialize-nd dimensions value) (if (=? (length dimensions) 0) value (map (lambda (_) (initialize-nd (tail dimensions) value)) (range 0 (head dimensions)))))
(define (neighbors-nd dimensions coordinates) (if (=? (length dimensions) 0) (list (list)) (reduce concat (map (lambda (suffix) (map (lambda (prefix) (concat (list prefix) suffix)) (range (max 0 (- (head coordinates) 1)) (min (head dimensions) (+ (head coordinates) 2))))) (neighbors-nd (tail dimensions) (tail coordinates))) (list))))
(define (get-nd board coordinates) (if (=? (length coordinates) 1) (nth board (head coordinates)) (get-nd (nth board (head coordinates)) (tail coordinates))))
(define (set-nd board coordinates value) (if (=? (length coordinates) 1) (set-nth board (head coordinates) value) (set-nth board (head coordinates) (set-nd (nth board (head coordinates)) (tail coordinates) value))))
(define (is-victory board mask dimensions) (if (=? (length dimensions) 0) (or mask (=? board -1)) (all (map (lambda (pair) (is-victory (head pair) (tail pair) (tail dimensions))) (zip board mask)))))
(define (game-get-state game) ((nth game 0)))
(define (game-set-state game state) ((nth game 1) state))
(define (game-get-board game) ((nth game 2)))
(define (game-set-board game board) ((nth game 3) board))
(define (game-get-mask game) ((nth game 4)))
(define (game-set-mask game mask) ((nth game 5) mask))
(define (game-get-dimensions game) ((nth game 6)))
(define (new-game-nd dimensions bombs) (begin (define state 0) (define board (initialize-nd dimensions 0)) (define mask (initialize-nd dimensions #f)) (define self (list (lambda () state) (lambda (new_state) (set! state new_state)) (lambda () board) (lambda (new_board) (set! board new_board)) (lambda () mask) (lambda (new_mask) (set! mask new_mask)) (lambda () dimensions))) (map (lambda (bomb) (begin (game-set-board self (set-nd (game-get-board self) bomb -1)) (map (lambda (neighbor) (begin (define value (get-nd (game-get-board self) neighbor)) (if (>= value 0) (game-set-board self (set-nd (game-get-board self) neighbor (+ value 1))) nil))) (neighbors-nd dimensions bomb)))) bombs) self))
(define (dig-nd game coordinates) (if (or (get-nd (game-get-mask game) coordinates) (not (=? (game-get-state game) 0))) 0 (if (=? (get-nd (game-get-board game) coordinates) -1) (begin (game-set-mask game (set-nd (game-get-mask game) coordinates #t)) (game-set-state game 2) 1) (begin (define (dig-helper coordinates) (if (get-nd (game-get-mask game) coordinates) 0 (begin (game-set-mask game (set-nd (game-get-mask game) coordinates #t)) (if (=? (get-nd (game-get-board game) coordinates) 0) (reduce + (map (lambda (neighbor) (dig-helper neighbor)) (neighbors-nd (game-get-dimensions game) coordinates)) 1) 1)))) (define count (dig-helper coordinates)) (if (is-victory (game-get-board game) (game-get-mask game) (game-get-dimensions game)) (game-set-state game 1) nil) count))))
(define game (new-game-nd (list 2 4) (list (list 0 0) (list 1 0) (list 1 1))))
(game-get-board game)
(dig-nd game (list 0 1))
(dig-nd game (list 0 3))
(game-get-board game)
(game-get-state game)
